# 타이머 시스템 구현 참고 가이드

## 📋 타이머 계획서 참고 설정

### 핵심 원칙
1. **기존 시스템 보호**: 현재 타이머 시스템을 그대로 유지
2. **완전 격리**: 새로운 타이머 시스템을 독립적으로 구현
3. **선택적 적용**: 필요에 따라 새로운 타이머 시스템 선택 적용
4. **안전한 전환**: 기존 시스템에 영향 없이 안전한 전환

### 참고 문서 목록
- **TIMER_IMPLEMENTATION_PLAN.md**: 타이머 시스템 구현 계획서
- **EXISTING_TIMER_ANALYSIS.md**: 기존 타이머 시스템 분석 보고서
- **NEW_TIMER_SYSTEM_DESIGN.md**: 새로운 타이머 시스템 설계 및 격리 방안
- **SAFE_IMPLEMENTATION_PLAN.md**: 안전한 구현 단계별 계획
- **TESTING_AND_VALIDATION_PLAN.md**: 테스트 및 검증 계획

## 🛡️ 기존 시스템 보호 방안

### 보호 대상 (수정 금지)
- **핵심 변수**: `matchTimerData`, `pendingDbUpdates`, `DB_BATCH_INTERVAL`
- **핵심 함수**: `startMatchTimer`, `stopMatchTimer`, `resetMatchTimer`, `setMatchTimer`
- **WebSocket 이벤트**: `timer_control`, `timer_sync`, `timer_state`
- **데이터베이스**: 기존 DB 구조와 필드

### 보호 수준
- **높은 보호 수준 (수정 금지)**: 핵심 변수, 함수, 이벤트
- **중간 보호 수준 (최소 수정)**: WebSocket 설정, 서버 설정, 모델 설정
- **낮은 보호 수준 (자유 수정)**: 새로운 파일, 새로운 기능, 새로운 설정

## 🏗️ 새로운 시스템 설계

### 파일 구조 (완전 격리)
```
websocket/events/
├── timer.js (기존 - 수정 금지)
├── timer-v2/ (신규 - 새로운 타이머 시스템)
│   ├── server-centric.js
│   ├── hybrid.js
│   ├── mode-manager.js
│   ├── sync-manager.js
│   └── index.js
└── index.js (기존 - 최소 수정)
```

### 네임스페이스 격리
- **기존 시스템**: `matchTimerData`, `startMatchTimer`, `timer_control`
- **새로운 시스템**: `serverCentricTimerData`, `startServerCentricTimer`, `timer_v2_control`

### 데이터베이스 격리
- **기존 시스템**: `timer_startTime`, `timer_pausedTime`, `isRunning`
- **새로운 시스템**: `timer_v2_startTime`, `timer_v2_pausedTime`, `timer_v2_isRunning`

## 🧪 테스트 및 검증

### 테스트 유형
1. **단위 테스트**: 각 타이머 시스템 독립 테스트
2. **통합 테스트**: 기존 시스템과 새로운 시스템 동시 실행 테스트
3. **성능 테스트**: 단일/다중 경기 타이머 성능 테스트
4. **호환성 테스트**: 기존 API/클라이언트/브라우저 호환성 테스트

### 성공 기준
- **기능적 성공**: 모든 기능이 정상 작동
- **성능적 성공**: 성능 저하 없이 작동
- **안정성 성공**: 시스템 장애 없이 작동
- **호환성 성공**: 기존 시스템과 호환

## 📅 구현 단계

### 1단계: 기존 시스템 보호 및 분석 (1주)
- [ ] 기존 타이머 시스템 완전 분석
- [ ] 기존 시스템 영향도 분석
- [ ] 보호 방안 수립
- [ ] 테스트 환경 구축

### 2단계: 새로운 시스템 기본 구조 구현 (1주)
- [ ] 새로운 타이머 시스템 기본 구조
- [ ] 완전 격리된 파일 구조
- [ ] 기본 클래스 및 인터페이스
- [ ] 단위 테스트 작성

### 3단계: 서버 중심 타이머 시스템 구현 (2주)
- [ ] ServerCentricTimer 클래스 구현
- [ ] WebSocket 이벤트 처리 구현
- [ ] 데이터베이스 연동 구현
- [ ] 단위 테스트 및 통합 테스트

### 4단계: 하이브리드 타이머 시스템 구현 (2주)
- [ ] HybridTimer 클래스 구현
- [ ] 서버-로컬 타이머 동기화
- [ ] 오프라인 지원 구현
- [ ] 단위 테스트 및 통합 테스트

### 5단계: 모드 관리 시스템 구현 (1주)
- [ ] TimerModeManager 클래스 구현
- [ ] 런타임 모드 전환 기능
- [ ] 설정 관리 시스템
- [ ] 단위 테스트 및 통합 테스트

### 6단계: 통합 테스트 및 검증 (1주)
- [ ] 기존 시스템과의 통합
- [ ] 성능 최적화
- [ ] 모니터링 시스템 구현
- [ ] 최종 테스트 및 검증

## 🚨 위험 요소 및 대응 방안

### 간섭 위험
- **위험 요소**: 새로운 시스템이 기존 시스템에 영향
- **대응 방안**: 완전한 네임스페이스 격리, 독립적인 이벤트 핸들러

### 성능 저하 위험
- **위험 요소**: 새로운 시스템으로 인한 성능 저하
- **대응 방안**: 선택적 로딩, 메모리 사용량 모니터링

### 데이터 손실 위험
- **위험 요소**: 새로운 시스템으로 인한 기존 데이터 손실
- **대응 방안**: 기존 데이터 백업, 점진적 마이그레이션

## 📊 모니터링 및 관리

### 실시간 모니터링
- 타이머 시스템 상태 모니터링
- 메모리 사용량 모니터링
- CPU 사용량 모니터링
- 네트워크 트래픽 모니터링

### 자동화된 관리
- 자동 복구 시스템
- 성능 최적화
- 알림 시스템
- 설정 관리

## 📝 결론

이 참고 가이드는 타이머 시스템 구현 시 항상 참고해야 하는 핵심 원칙과 방안을 담고 있습니다.

**구현 시 주의사항:**
1. **기존 시스템 보호**: 현재 시스템을 그대로 유지
2. **완전 격리**: 새로운 시스템을 독립적으로 구현
3. **선택적 적용**: 필요에 따라 새로운 시스템 선택 적용
4. **안전한 전환**: 기존 시스템에 영향 없이 안전한 전환

**성공을 위한 핵심 요소:**
- 철저한 분석과 계획
- 단계별 안전한 구현
- 지속적인 테스트와 검증
- 기존 시스템과의 완전한 격리

이 가이드를 바탕으로 안전하고 효과적인 타이머 시스템을 구현하겠습니다.
