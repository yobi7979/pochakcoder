# 타이머 시스템 분석 및 해결 방안 (2024년 10월)

## 🎯 사용자 요구사항 분석

### ✅ 해결해야 할 문제들
1. **다른 PC에서 오버레이 표시**: 컨트롤 페이지와 오버레이 페이지가 다른 PC에서 실행
2. **PC 시간대 차이**: 각 PC의 시간이 달라서 동기화 문제 발생  
3. **실시간 동기화**: 컨트롤 페이지와 오버레이 페이지 간 완벽한 동기화
4. **서버 보조 역할**: 서버는 보조적 역할만 수행
5. **서버 중단 시 지속성**: 서버 중단 시에도 타이머 계속 동작

## 🔍 현재 타이머 시스템 분석

### 📁 현재 시스템 구조

#### 1. **기존 타이머 시스템** (`websocket/events/timer.js`)
- **메모리 기반**: `matchTimerData` Map 사용
- **WebSocket 이벤트**: `timer_control`, `timer_sync`, `request_timer_state`
- **하이브리드 방식**: 서버 시간 + 로컬 시간 결합
- **DB 배치 업데이트**: 5초마다 배치로 DB 업데이트

#### 2. **새로운 타이머 시스템 v2** (`websocket/events/timer-v2-simple.js`)
- **서버 중심**: `global.timerV2States` Map 사용
- **WebSocket 이벤트**: `server_timer_control`, `request_server_timer_state`
- **완전 서버 중심**: 서버가 모든 타이머 상태 관리
- **선택적 로딩**: `ENABLE_NEW_TIMER` 환경 변수로 제어

#### 3. **프론트엔드 타이머 코드**
- **컨트롤 패널** (`soccer-control.ejs`): 타이머 제어 UI
- **오버레이 페이지** (`soccer-template.ejs`): 타이머 표시 UI

### 🎯 시스템 비교표

| 구분 | 기존 타이머 시스템 | 새로운 타이머 시스템 v2 |
|------|------------------|----------------------|
| **데이터 저장** | `matchTimerData` Map | `global.timerV2States` Map |
| **제어 방식** | 하이브리드 (서버+로컬) | 서버 중심 |
| **WebSocket 이벤트** | `timer_control`, `timer_sync` | `server_timer_control` |
| **동기화** | 클라이언트 시간 기반 | 서버 시간 기반 |
| **시간대 독립성** | ❌ 클라이언트 시간 의존 | ✅ 서버 시간 기준 |
| **오프라인 지원** | ✅ 로컬 타이머 유지 | ❌ 서버 의존적 |

## ❌ 현재 문제점 진단

### 1. **이벤트 불일치**
- **컨트롤 패널**: `timer_control` 이벤트 사용 (기존 시스템)
- **오버레이 페이지**: `request_timer_state` 이벤트 사용 (기존 시스템)
- **새로운 시스템**: `server_timer_control` 이벤트 사용 (v2 시스템)

### 2. **환경 변수 충돌**
```javascript
// 로컬 환경
ENABLE_NEW_TIMER=false  // 기존 시스템 사용

// Railway 환경  
ENABLE_NEW_TIMER=true   // 새로운 시스템 사용
```

### 3. **동기화 실패 원인**
- **로컬**: 기존 시스템 사용하지만 오버레이 페이지가 이벤트를 받지 못함
- **Railway**: 새로운 시스템 사용하지만 컨트롤 패널이 다른 이벤트 사용

## 🏗️ 최적 솔루션: **하이브리드 타이머 시스템**

### 📋 핵심 설계 원칙
```javascript
// 1. 서버 연결 시: 서버 중심 타이머
// 2. 서버 중단 시: 로컬 타이머로 자동 전환
// 3. 서버 복구 시: 자동 동기화
// 4. 시간대 독립: 모든 클라이언트가 동일한 시간 유지
```

### 🎯 시스템 아키텍처
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   컨트롤 패널    │    │   서버 (보조)    │    │   오버레이 페이지 │
│                 │    │                 │    │                 │
│ 로컬 타이머     │◄──►│ 서버 동기화     │◄──►│ 로컬 타이머     │
│ + 서버 동기화   │    │ + 상태 관리     │    │ + 서버 동기화   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 🔧 동작 시나리오
1. **서버 연결 시**: 서버 시간 기준으로 모든 클라이언트 동기화
2. **서버 중단 시**: 각 클라이언트의 로컬 타이머로 자동 전환
3. **서버 복구 시**: 서버 상태와 로컬 상태를 비교하여 자동 동기화
4. **시간대 차이**: 서버 시간 기준으로 통일하여 PC 시간대 차이 해결

## 📋 구현 방향

### **1단계: 통합 타이머 시스템 구축**
- 기존 시스템과 새로운 시스템을 통합
- 하이브리드 방식으로 서버 우선, 로컬 백업

### **2단계: 실시간 동기화 강화**
- WebSocket을 통한 실시간 타이머 상태 전파
- 서버 중단 감지 및 자동 전환

### **3단계: 시간대 독립성 확보**
- 서버 시간 기준으로 모든 클라이언트 동기화
- PC 시간대 차이 무시

## 🎯 해결 방안

### **방안 1: 통합 타이머 시스템** (권장)
```javascript
// 모든 환경에서 동일한 타이머 시스템 사용
// 서버 중심 + 로컬 백업 하이브리드 방식
```

### **방안 2: 환경별 최적화**
```javascript
// 로컬: 기존 시스템 완전 수정
// Railway: 새로운 시스템 완전 적용
```

### **방안 3: 하이브리드 시스템**
```javascript
// 서버 연결 시: 서버 중심
// 서버 중단 시: 로컬 타이머
// 자동 전환 및 동기화
```

## 📚 참고 문서 업데이트

### 기존 문서들
- **TIMER_IMPLEMENTATION_PLAN.md**: 타이머 시스템 구현 계획서
- **TIMER_REFERENCE_GUIDE.md**: 타이머 시스템 구현 참고 가이드
- **EXISTING_TIMER_ANALYSIS.md**: 기존 타이머 시스템 분석 보고서

### 새로운 문서
- **TIMER_SYSTEM_ANALYSIS_2024.md**: 현재 분석 및 해결 방안 (이 문서)

## 📝 결론

사용자 요구사항에 따른 최적 솔루션은 **하이브리드 타이머 시스템**입니다.

**핵심 특징:**
1. **서버 우선**: 서버 연결 시 서버 시간 기준
2. **로컬 백업**: 서버 중단 시 로컬 타이머 유지
3. **자동 동기화**: 서버 복구 시 자동 동기화
4. **시간대 독립**: 모든 클라이언트가 동일한 시간 유지

이를 통해 다른 PC에서 오버레이 표시, PC 시간대 차이 해결, 실시간 동기화, 서버 보조 역할, 서버 중단 시 지속성을 모두 만족할 수 있습니다.
