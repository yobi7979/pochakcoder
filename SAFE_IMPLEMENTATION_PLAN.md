# 안전한 구현 단계별 계획

## 🎯 구현 원칙

### 핵심 원칙
1. **기존 시스템 보호**: 현재 타이머 시스템을 그대로 유지
2. **완전 격리**: 새로운 타이머 시스템을 독립적으로 구현
3. **선택적 적용**: 필요에 따라 새로운 타이머 시스템 선택 적용
4. **안전한 전환**: 기존 시스템에 영향 없이 안전한 전환

### 안전성 보장
- **간섭 방지**: 기존 시스템과 새로운 시스템 간 간섭 완전 방지
- **롤백 가능**: 문제 발생 시 즉시 기존 시스템으로 롤백
- **데이터 보존**: 기존 데이터 완전 보존
- **성능 유지**: 기존 시스템 성능 유지

## 📋 1단계: 기존 시스템 보호 및 분석 (1주)

### 1.1 기존 시스템 완전 분석
- [ ] **기존 타이머 시스템 코드 분석**
  - `websocket/events/timer.js` (372줄) 완전 분석
  - 핵심 변수: `matchTimerData`, `pendingDbUpdates` 분석
  - 핵심 함수: `startMatchTimer`, `stopMatchTimer` 분석
  - WebSocket 이벤트: `timer_control`, `timer_sync` 분석

- [ ] **기존 클라이언트 코드 분석**
  - `views/soccer-control.ejs` 타이머 코드 분석
  - `views/soccer-template.ejs` 타이머 코드 분석
  - `views/baseball-control.ejs` 타이머 코드 분석
  - `views/baseball-template.ejs` 타이머 코드 분석

- [ ] **기존 데이터베이스 구조 분석**
  - Match 모델의 `match_data` 필드 분석
  - 기존 타이머 데이터 저장 방식 분석
  - DB 업데이트 패턴 분석

### 1.2 보호 방안 수립
- [ ] **변수명 보호 계획**
  - 기존 변수명: `matchTimerData`, `pendingDbUpdates` 보호
  - 새로운 변수명: `serverCentricTimerData`, `hybridTimerData` 사용

- [ ] **함수명 보호 계획**
  - 기존 함수명: `startMatchTimer`, `stopMatchTimer` 보호
  - 새로운 함수명: `startServerCentricTimer`, `startHybridTimer` 사용

- [ ] **WebSocket 이벤트 보호 계획**
  - 기존 이벤트: `timer_control`, `timer_sync` 보호
  - 새로운 이벤트: `timer_v2_control`, `timer_v2_sync` 사용

### 1.3 테스트 환경 구축
- [ ] **기존 시스템 테스트 환경 구축**
  - 기존 타이머 시스템 단위 테스트 작성
  - 기존 시스템 성능 테스트 작성
  - 기존 시스템 통합 테스트 작성

- [ ] **새로운 시스템 테스트 환경 구축**
  - 새로운 타이머 시스템 테스트 환경 구축
  - 간섭 테스트 환경 구축
  - 성능 비교 테스트 환경 구축

## 📋 2단계: 새로운 시스템 기본 구조 구현 (1주)

### 2.1 독립적인 파일 구조 생성
- [ ] **새로운 타이머 시스템 디렉토리 생성**
  ```
  websocket/events/timer-v2/
  ├── server-centric.js
  ├── hybrid.js
  ├── mode-manager.js
  ├── sync-manager.js
  └── index.js
  ```

- [ ] **기존 파일 보호**
  - `websocket/events/timer.js` 수정 금지
  - `websocket/events/index.js` 최소 수정
  - 기존 클라이언트 파일 수정 금지

### 2.2 기본 클래스 및 인터페이스 구현
- [ ] **ServerCentricTimer 클래스 구현**
  ```javascript
  class ServerCentricTimer {
      constructor() {
          this.timerData = new Map();
          this.isActive = false;
      }
      
      startTimer(matchId) { /* 새로운 로직 */ }
      stopTimer(matchId) { /* 새로운 로직 */ }
      resetTimer(matchId) { /* 새로운 로직 */ }
      getCurrentTime(matchId) { /* 새로운 로직 */ }
  }
  ```

- [ ] **HybridTimer 클래스 구현**
  ```javascript
  class HybridTimer {
      constructor() {
          this.serverTimer = new ServerTimer();
          this.localTimer = new LocalTimer();
          this.isActive = false;
      }
      
      startTimer(matchId) { /* 새로운 로직 */ }
      stopTimer(matchId) { /* 새로운 로직 */ }
      syncWithServer(matchId) { /* 새로운 로직 */ }
      fallbackToLocal(matchId) { /* 새로운 로직 */ }
  }
  ```

### 2.3 단위 테스트 작성
- [ ] **각 클래스별 단위 테스트**
  - ServerCentricTimer 단위 테스트
  - HybridTimer 단위 테스트
  - TimerModeManager 단위 테스트

- [ ] **기존 시스템과의 간섭 테스트**
  - 기존 변수와의 충돌 테스트
  - 기존 함수와의 충돌 테스트
  - 기존 WebSocket 이벤트와의 충돌 테스트

## 📋 3단계: 서버 중심 타이머 시스템 구현 (2주)

### 3.1 ServerCentricTimer 클래스 구현
- [ ] **핵심 기능 구현**
  - 타이머 시작/정지/리셋 기능
  - 서버 시간 기준 동기화
  - 실시간 상태 업데이트
  - 데이터베이스 연동

- [ ] **WebSocket 이벤트 처리**
  - `timer_v2_control` 이벤트 처리
  - `timer_v2_sync` 이벤트 처리
  - `timer_v2_state` 이벤트 처리

### 3.2 데이터베이스 연동 구현
- [ ] **독립적인 DB 필드 사용**
  - `timer_v2_startTime` 필드 사용
  - `timer_v2_pausedTime` 필드 사용
  - `timer_v2_isRunning` 필드 사용
  - `timer_v2_mode` 필드 사용

- [ ] **트랜잭션 격리**
  - 기존 DB 필드와 독립적인 트랜잭션
  - 동시 접근 충돌 방지
  - 데이터 일관성 보장

### 3.3 통합 테스트 작성
- [ ] **기존 시스템과의 호환성 테스트**
  - 기존 타이머 시스템 정상 작동 확인
  - 새로운 타이머 시스템 정상 작동 확인
  - 두 시스템 간 간섭 없음 확인

- [ ] **성능 테스트**
  - 기존 시스템 성능 유지 확인
  - 새로운 시스템 성능 기준 달성 확인
  - 메모리 사용량 증가 < 20% 확인

## 📋 4단계: 하이브리드 타이머 시스템 구현 (2주)

### 4.1 HybridTimer 클래스 구현
- [ ] **서버-로컬 타이머 결합**
  - 서버 연결 시 서버 중심 동작
  - 서버 중단 시 로컬 타이머로 전환
  - 서버 복구 시 자동 동기화

- [ ] **오프라인 지원**
  - 네트워크 연결 끊김 감지
  - 로컬 타이머로 자동 전환
  - 서버 복구 시 자동 동기화

### 4.2 동기화 시스템 구현
- [ ] **실시간 동기화**
  - 서버 시간과 로컬 시간 동기화
  - 네트워크 지연 보정
  - 시간차 최소화

- [ ] **충돌 해결**
  - 서버와 로컬 상태 충돌 해결
  - 우선순위 기반 상태 선택
  - 자동 복구 시스템

### 4.3 통합 테스트 작성
- [ ] **하이브리드 시스템 테스트**
  - 서버 연결 시 정상 동작 확인
  - 서버 중단 시 로컬 전환 확인
  - 서버 복구 시 자동 동기화 확인

- [ ] **성능 테스트**
  - 하이브리드 시스템 성능 테스트
  - 메모리 사용량 테스트
  - CPU 사용량 테스트

## 📋 5단계: 모드 관리 시스템 구현 (1주)

### 5.1 TimerModeManager 클래스 구현
- [ ] **모드 전환 기능**
  - 런타임 모드 전환
  - 경기별 모드 설정
  - 모드별 설정 관리

- [ ] **설정 관리**
  - 모드별 설정 저장
  - 설정 백업 및 복원
  - 설정 상속 시스템

### 5.2 통합 관리 시스템 구현
- [ ] **IntegratedTimerManager 클래스**
  - 기존 시스템과 새로운 시스템 통합 관리
  - 모드별 타이머 시스템 선택
  - 통합 상태 관리

- [ ] **자동화된 관리**
  - 성능 모니터링
  - 자동 최적화
  - 장애 복구

### 5.3 통합 테스트 작성
- [ ] **모드 전환 테스트**
  - 런타임 모드 전환 테스트
  - 모드별 설정 적용 테스트
  - 모드 전환 시 데이터 보존 테스트

- [ ] **통합 시스템 테스트**
  - 전체 시스템 통합 테스트
  - 성능 테스트
  - 안정성 테스트

## 📋 6단계: 통합 및 최적화 (1주)

### 6.1 기존 시스템과의 통합
- [ ] **호환성 보장**
  - 기존 API 호환성 확인
  - 기존 클라이언트 호환성 확인
  - 기존 데이터 호환성 확인

- [ ] **점진적 마이그레이션**
  - 기존 시스템에서 새로운 시스템으로 점진적 전환
  - 데이터 마이그레이션
  - 설정 마이그레이션

### 6.2 성능 최적화
- [ ] **메모리 최적화**
  - 메모리 사용량 최적화
  - 가비지 컬렉션 최적화
  - 메모리 누수 방지

- [ ] **성능 최적화**
  - CPU 사용량 최적화
  - 네트워크 트래픽 최적화
  - 데이터베이스 쿼리 최적화

### 6.3 최종 테스트 및 검증
- [ ] **전체 시스템 테스트**
  - 기존 시스템 정상 작동 확인
  - 새로운 시스템 정상 작동 확인
  - 두 시스템 간 간섭 없음 확인

- [ ] **성능 테스트**
  - 전체 시스템 성능 테스트
  - 부하 테스트
  - 안정성 테스트

- [ ] **사용자 테스트**
  - 실제 사용자 테스트
  - 피드백 수집
  - 문제점 개선

## 🧪 테스트 및 검증 계획

### 1. 단위 테스트
- [ ] **각 타이머 시스템 독립 테스트**
  - ServerCentricTimer 단위 테스트
  - HybridTimer 단위 테스트
  - TimerModeManager 단위 테스트

- [ ] **기존 시스템과의 간섭 테스트**
  - 변수 충돌 테스트
  - 함수 충돌 테스트
  - WebSocket 이벤트 충돌 테스트

### 2. 통합 테스트
- [ ] **기존 시스템과 새로운 시스템 동시 실행 테스트**
  - 두 시스템이 독립적으로 작동하는지 확인
  - 간섭 없이 작동하는지 확인
  - 성능 저하 없이 작동하는지 확인

### 3. 성능 테스트
- [ ] **단일 경기 타이머 성능 테스트**
  - 기존 시스템 성능 테스트
  - 새로운 시스템 성능 테스트
  - 성능 비교 분석

- [ ] **다중 경기 타이머 성능 테스트**
  - 10개 경기 동시 실행 테스트
  - 100개 경기 동시 실행 테스트
  - 서버 부하 테스트

### 4. 호환성 테스트
- [ ] **기존 API 호환성 테스트**
  - 기존 API 정상 작동 확인
  - 기존 클라이언트 호환성 확인
  - 기존 데이터 호환성 확인

- [ ] **브라우저 호환성 테스트**
  - Chrome 호환성 테스트
  - Firefox 호환성 테스트
  - Safari 호환성 테스트
  - Edge 호환성 테스트

## 🚨 위험 요소 및 대응 방안

### 1. 기존 시스템 간섭 위험
**위험 요소:**
- 새로운 타이머 시스템이 기존 시스템에 영향
- WebSocket 이벤트 충돌
- 데이터베이스 동시 접근 충돌

**대응 방안:**
- 완전한 네임스페이스 격리
- 독립적인 이벤트 핸들러
- 데이터베이스 트랜잭션 격리

### 2. 성능 저하 위험
**위험 요소:**
- 새로운 타이머 시스템으로 인한 성능 저하
- 메모리 사용량 증가
- CPU 사용량 증가

**대응 방안:**
- 선택적 로딩 (필요한 시스템만 로딩)
- 메모리 사용량 모니터링
- 성능 최적화

### 3. 데이터 손실 위험
**위험 요소:**
- 새로운 시스템으로 인한 기존 데이터 손실
- 타이머 상태 불일치
- 동기화 실패

**대응 방안:**
- 기존 데이터 백업
- 점진적 마이그레이션
- 롤백 계획 수립

## 📊 모니터링 및 관리

### 1. 실시간 모니터링
- [ ] **시스템 상태 모니터링**
  - 기존 타이머 시스템 상태 모니터링
  - 새로운 타이머 시스템 상태 모니터링
  - 두 시스템 간 간섭 모니터링

- [ ] **성능 모니터링**
  - 메모리 사용량 모니터링
  - CPU 사용량 모니터링
  - 네트워크 트래픽 모니터링

### 2. 자동화된 관리
- [ ] **자동 복구 시스템**
  - 시스템 장애 시 자동 복구
  - 기존 시스템으로 자동 전환
  - 알림 시스템

- [ ] **성능 최적화**
  - 자동 성능 최적화
  - 메모리 정리
  - 캐시 최적화

## 🎯 성공 기준

### 1. 기능적 성공 기준
- [ ] **기존 타이머 시스템 정상 작동**
  - 모든 기존 기능 정상 작동
  - 기존 성능 유지
  - 기존 데이터 보존

- [ ] **새로운 타이머 시스템 정상 작동**
  - 서버 중심 타이머 시스템 정상 작동
  - 하이브리드 타이머 시스템 정상 작동
  - 모드 전환 기능 정상 작동

### 2. 성능적 성공 기준
- [ ] **기존 시스템 성능 유지**
  - 메모리 사용량 증가 < 20%
  - CPU 사용량 증가 < 15%
  - 네트워크 트래픽 증가 < 10%

- [ ] **새로운 시스템 성능 기준 달성**
  - 서버 중심 타이머: 동기화 정확도 > 99.9%
  - 하이브리드 타이머: 오프라인 지원 > 99.5%
  - 모드 전환: 전환 시간 < 1초

### 3. 안정성 성공 기준
- [ ] **시스템 장애율 < 0.1%**
- [ ] **데이터 손실 없음**
- [ ] **타이머 정확도 > 99.9%**
- [ ] **동기화 성공률 > 99.5%**

## 📅 일정 및 마일스톤

### 전체 일정: 8주
- **1주차**: 기존 시스템 보호 및 분석
- **2주차**: 새로운 시스템 기본 구조 구현
- **3-4주차**: 서버 중심 타이머 시스템 구현
- **5-6주차**: 하이브리드 타이머 시스템 구현
- **7주차**: 모드 관리 시스템 구현
- **8주차**: 통합 테스트 및 검증

### 주요 마일스톤
- **M1**: 기존 시스템 보호 완료
- **M2**: 새로운 시스템 기본 구조 완료
- **M3**: 서버 중심 타이머 시스템 완료
- **M4**: 하이브리드 타이머 시스템 완료
- **M5**: 모드 관리 시스템 완료
- **M6**: 통합 테스트 및 검증 완료

## 📝 결론

이 계획서는 기존 타이머 시스템을 보호하면서 새로운 타이머 기능을 안전하게 추가하는 것을 목표로 합니다.

**핵심 원칙:**
1. **기존 시스템 보호**: 현재 시스템을 그대로 유지
2. **완전 격리**: 새로운 시스템을 독립적으로 구현
3. **선택적 적용**: 필요에 따라 새로운 시스템 선택 적용
4. **안전한 전환**: 기존 시스템에 영향 없이 안전한 전환

**성공을 위한 핵심 요소:**
- 철저한 분석과 계획
- 단계별 안전한 구현
- 지속적인 테스트와 검증
- 기존 시스템과의 완전한 격리

이 계획에 따라 단계별로 진행하면서 각 단계마다 철저한 테스트와 검증을 통해 안전한 구현을 보장하겠습니다.
